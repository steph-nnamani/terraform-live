permissions:
  id-token: write
  contents: read 
name: Terraform Apply
on:
  push:
    branches:
      - main

jobs:
  terraform-apply:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Authenticate to AWS using OIDC
        uses: aws-actions/configure-aws-credentials@v1
        with:
          # specify the IAM role to assume here
          role-to-assume: "arn:aws:iam::418272752575:role/github-actions-oidc-example20250511055154010500000001"
          aws-region: us-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: 1.1.0  
          terraform_wrapper: false

      # - name: Check and Force Unlock MySQL State (if needed)
      #   working-directory: ./prod/data-stores/mysql
      #   run: |
      #     terraform init
      #     # Try to apply with a timeout
      #     timeout 30s terraform apply -auto-approve || \
      #     # If it times out or fails, try to identify if it's a lock issue
      #     if terraform state list 2>&1 | grep -q "Error acquiring the state lock"; then
      #       # Extract lock ID and force unlock
      #       LOCK_ID=$(terraform state pull 2>&1 | grep -o "ID:[[:space:]]*[a-z0-9-]*" | cut -d' ' -f2)
      #       if [ ! -z "$LOCK_ID" ]; then
      #         echo "Force unlocking state with ID: $LOCK_ID"
      #         terraform force-unlock -force $LOCK_ID
      #         # Try apply again after unlocking
      #         terraform apply -auto-approve
      #       fi
      #     fi

      # - name: Check and Force Unlock Webserver Cluster State (if needed)
      #   working-directory: ./prod/services/webserver-cluster
      #   run: |
      #     terraform init
      #     # Try to apply with a timeout
      #     timeout 30s terraform apply -auto-approve || \
      #     # If it times out or fails, try to identify if it's a lock issue
      #     if terraform state list 2>&1 | grep -q "Error acquiring the state lock"; then
      #       # Extract lock ID and force unlock
      #       LOCK_ID=$(terraform state pull 2>&1 | grep -o "ID:[[:space:]]*[a-z0-9-]*" | cut -d' ' -f2)
      #       if [ ! -z "$LOCK_ID" ]; then
      #         echo "Force unlocking state with ID: $LOCK_ID"
      #         terraform force-unlock -force $LOCK_ID
      #         # Try apply again after unlocking
      #         terraform apply -auto-approve
      #       fi
      #     fi

      - name: Terraform init and apply MySQL
        id: mysql
        working-directory: ./prod/data-stores/mysql
        run: |
          terraform init
          terraform apply -auto-approve
        # This ensures the step is marked as failed if any command fails
        shell: bash {0}

      # This step will only run if the MySQL step succeeds
      - name: Terraform init and apply Webserver Cluster
        id: webserver
        if: success() && steps.mysql.outcome == 'success'
        working-directory: ./prod/services/webserver-cluster
        run: |
          terraform init
          terraform apply -auto-approve
        shell: bash {0}

      - name: Test MySQL Database
        if: success() && steps.mysql.outcome == 'success'
        run: |
          # Install MySQL client
          sudo apt-get update
          sudo apt-get install -y mysql-client
          
          # Extract MySQL endpoint and port from Terraform output
          DB_ADDRESS=$(cd ./prod/data-stores/mysql && terraform output -raw address)
          DB_PORT=$(cd ./prod/data-stores/mysql && terraform output -raw port)
          
          echo "Testing connection to MySQL database at $DB_ADDRESS:$DB_PORT..."
          
          # Wait for RDS to become fully available
          echo "Waiting for 30 seconds for RDS to become ready..."
          sleep 30
          
          # Try to connect to the MySQL database
          # Note: We're just testing connectivity, not authentication
          mysqladmin ping -h $DB_ADDRESS -P $DB_PORT --connect-timeout=5 || echo "::warning::MySQL connectivity test failed, but continuing"
          
          # Alternative test using netcat to check if port is open
          echo "Testing port connectivity with netcat..."
          nc -zv $DB_ADDRESS $DB_PORT -w 5
          
          if [ $? -eq 0 ]; then
            echo -e "\nSuccess: MySQL port is open and responding"
          else
            echo -e "\nWarning: MySQL port connectivity test failed"
            echo "::warning::MySQL port connectivity test failed"
          fi

      - name: Test Webserver Infrastructure
        if: success() && steps.webserver.outcome == 'success'
        run: |
          # Extract ALB DNS name from Terraform output
          ALB_DNS=$(cd ./prod/services/webserver-cluster && terraform output -raw alb_dns_name)
          
          echo "Testing connection to $ALB_DNS..."
          
          # Wait for ALB to become ready
          echo "Waiting for 60 seconds for ALB to become ready..."
          sleep 60
          
          # Try to curl the ALB DNS name
          curl -m 15 http://$ALB_DNS
          
          # Check the curl exit status
          if [ $? -eq 0 ]; then
            echo -e "\nSuccess: Server is responding"
          else
            echo -e "\nError: Server is not responding"
            # Mark as warning but don't fail the workflow
            echo "::warning::ALB endpoint test failed"
          fi